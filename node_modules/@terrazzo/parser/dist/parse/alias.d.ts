import type { ObjectNode } from '@humanwhocodes/momoa';
import { type TokenNormalized, type TokenNormalizedSet } from '@terrazzo/token-tools';
import type Logger from '../logger.js';
export interface ApplyAliasOptions {
    tokensSet: TokenNormalizedSet;
    filename: URL;
    src: string;
    node: ObjectNode;
    logger: Logger;
}
export type PreAliased<T extends TokenNormalized> = {
    $value: T['$value'] | string;
    mode: Record<string, T['mode'][string] & {
        $value: T['$value'] | string;
    }>;
};
/**
 * Resolve aliases and update the token nodes.
 *
 * Data structures are in an awkward in-between phase, where they have
 * placeholders for data but we still need to resolve everything. As such,
 * TypeScript will raise errors expecting the final shape.
 *
 * This is also a bit tricky because different token types alias slightly
 * differently. For example, color tokens and other “primitive” tokens behave
 * as-expected. But composite tokens like Typography, Gradient, Border, etc. can
 * either fully- or partially-alias their values. Then we add modes to the mix,
 * and we have to do the work all over again for each mode declared.
 *
 * All that to say, there are a generous amount of TypeScript overrides here rather
 * than try to codify indeterminate shapes.
 */
export default function applyAliases(token: TokenNormalized, options: ApplyAliasOptions): void;
//# sourceMappingURL=alias.d.ts.map