import pc from 'picocolors';
import wcmatch from 'wildcard-match';
import { codeFrameColumns } from './lib/code-frame.js';
export const LOG_ORDER = ['error', 'warn', 'info', 'debug'];
const MESSAGE_COLOR = { error: pc.red, warn: pc.yellow };
const timeFormatter = new Intl.DateTimeFormat('en-us', {
    hour: 'numeric',
    hour12: false,
    minute: 'numeric',
    second: 'numeric',
    fractionalSecondDigits: 3,
});
/**
 * @param {Entry} entry
 * @param {Severity} severity
 * @return {string}
 */
export function formatMessage(entry, severity) {
    let message = entry.message;
    message = `[${entry.group}${entry.label ? `:${entry.label}` : ''}] ${message}`;
    if (severity in MESSAGE_COLOR) {
        message = MESSAGE_COLOR[severity](message);
    }
    if (entry.src) {
        const start = entry.node?.loc?.start ?? { line: 0, column: 0 };
        //  strip "file://" protocol, but not href
        const loc = entry.filename
            ? `${entry.filename?.href.replace(/^file:\/\//, '')}:${start?.line ?? 0}:${start?.column ?? 0}\n\n`
            : '';
        const codeFrame = codeFrameColumns(entry.src, { start }, { highlightCode: false });
        message = `${message}\n\n${loc}${codeFrame}`;
    }
    return message;
}
export default class Logger {
    level = 'info';
    debugScope = '*';
    errorCount = 0;
    warnCount = 0;
    infoCount = 0;
    debugCount = 0;
    constructor(options) {
        if (options?.level) {
            this.level = options.level;
        }
        if (options?.debugScope) {
            this.debugScope = options.debugScope;
        }
    }
    setLevel(level) {
        this.level = level;
    }
    /** Log an error message (always; canâ€™t be silenced) */
    error(entry) {
        this.errorCount++;
        const message = formatMessage(entry, 'error');
        if (entry.continueOnError) {
            console.error(message);
            return;
        }
        if (entry.node) {
            throw new TokensJSONError(message);
        }
        else {
            throw new Error(message);
        }
    }
    /** Log an info message (if logging level permits) */
    info(entry) {
        this.infoCount++;
        if (this.level === 'silent' || LOG_ORDER.indexOf(this.level) < LOG_ORDER.indexOf('info')) {
            return;
        }
        const message = formatMessage(entry, 'info');
        // biome-ignore lint/suspicious/noConsoleLog: this is its job
        console.log(message);
    }
    /** Log a warning message (if logging level permits) */
    warn(entry) {
        this.warnCount++;
        if (this.level === 'silent' || LOG_ORDER.indexOf(this.level) < LOG_ORDER.indexOf('warn')) {
            return;
        }
        const message = formatMessage(entry, 'warn');
        console.warn(message);
    }
    /** Log a diagnostics message (if logging level permits) */
    debug(entry) {
        if (this.level === 'silent' || LOG_ORDER.indexOf(this.level) < LOG_ORDER.indexOf('debug')) {
            return;
        }
        this.debugCount++;
        let message = formatMessage(entry, 'debug');
        const debugPrefix = entry.label ? `${entry.group}:${entry.label}` : entry.group;
        if (this.debugScope !== '*' && !wcmatch(this.debugScope)(debugPrefix)) {
            return;
        }
        // debug color
        message
            .replace(/\[config[^\]]+\]/, (match) => pc.green(match))
            .replace(/\[parser[^\]]+\]/, (match) => pc.magenta(match))
            .replace(/\[lint[^\]]+\]/, (match) => pc.yellow(match))
            .replace(/\[plugin[^\]]+\]/, (match) => pc.cyan(match));
        message = `${pc.dim(timeFormatter.format(performance.now()))} ${message}`;
        if (typeof entry.timing === 'number') {
            let timing = '';
            if (entry.timing < 1_000) {
                timing = `${Math.round(entry.timing * 100) / 100}ms`;
            }
            else if (entry.timing < 60_000) {
                timing = `${Math.round(entry.timing * 100) / 100_000}s`;
            }
            message = `${message} ${pc.dim(`[${timing}]`)}`;
        }
        // biome-ignore lint/suspicious/noConsoleLog: this is its job
        console.log(message);
    }
    /** Get stats for current logger instance */
    stats() {
        return {
            errorCount: this.errorCount,
            warnCount: this.warnCount,
            infoCount: this.infoCount,
            debugCount: this.debugCount,
        };
    }
}
export class TokensJSONError extends Error {
    constructor(message) {
        super(message);
        this.name = 'TokensJSONError';
    }
}
//# sourceMappingURL=logger.js.map